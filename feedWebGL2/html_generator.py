"""
Generate packaged HTML for displaying isosurface volumes of a numpy array. 

The HTML tree generated by this process must be viewed using a web server using
the HTTP protocol.  The file: protocol will not work because the HTML page loads
data files.
"""

# References:
# dumping: https://github.com/flatironinstitute/radiation_viz/blob/master/radiation_viz/dump_json_and_binary.py
# loading: https://github.com/flatironinstitute/radiation_viz/blob/master/radiation_viz/viz_template/main.js#L128
# options -- follow volume32.Volume32.load_3d_numpy_array

import jp_proxy_widget
import numpy as np
import json
import os
import shutil
from feedWebGL2 import local_files

DEFAULT_TITLE = "Array Isosurface Visualization"

DEFAULT_EXPLANATION = """
<p>
This interactive visualization allows you to explore the
contents of a dense array of values by viewing its slices
and its 3 dimensional iso-surfaces.
</p>

<p>
Adjust the isosurface threshold value by moving the colored slider or by clicking on
on the slice images.
</p>

<p>
Rotate the 3 dimensional views by dragging over the dot cloud.
</p>
"""

def generate_volume_html(ary, to_path, force=False, width=None, **kw):
    return VolumeHTMLGenerator(ary=ary, to_path=to_path, verbose=True, force=force, width=width, **kw)

class VolumeHTMLGenerator:

    def __init__(
        self,
        ary, 
        title=DEFAULT_TITLE,
        explanation=DEFAULT_EXPLANATION,
        threshold=None, 
        shrink_factor=None, 
        #method="cubes",
        camera_up=dict(x=0, y=1, z=0),
        camera_offset=dict(x=0, y=0, z=1),
        camera_distance_multiple=2.0,
        di=dict(x=1, y=0, z=0),  # xyz offset between ary[0,0,0] and ary[1,0,0]
        dj=dict(x=0, y=1, z=0),  # xyz offset between ary[0,0,0] and ary[0,1,0]
        dk=dict(x=0, y=0, z=1),  # xyz offset between ary[0,0,0] and ary[0,0,1]
        width=None,
        verbose=True,
        to_path=None,
        force=False,
    ):
        self.verbose = verbose
        self.title = title
        self.explanation = explanation
        self.force = force
        (num_layers, num_rows, num_cols) = ary.shape
        self.ary = ary
        self.dk = self.positional_xyz(dk)
        self.di = self.positional_xyz(di)
        self.dj = self.positional_xyz(dj)
        if threshold is None:
            threshold = ary.mean()
        self.options = jp_proxy_widget.clean_dict(
            num_rows=num_rows, 
            num_cols=num_cols, 
            num_layers=num_layers, 
            threshold=threshold, 
            shrink_factor=shrink_factor, 
            #method=method,
            camera_up=camera_up, 
            camera_offset=camera_offset,
            camera_distance_multiple=camera_distance_multiple,
            di=self.di, dj=self.dj, dk=self.dk,
            width=width,
        )
        if verbose:
            print (__doc__)
        if to_path is not None:
            self.create_folder(to_path)

    def create_folder(self, folder_path, force=False):
        force = force or self.force
        if self.verbose:
            print("Checking folder", folder_path)
        if os.path.exists(folder_path):
            if not force:
                raise FolderExists("Path exists -- please set force=True or delete manually: " + repr(folder_path))
            if self.verbose:
                print("Removing existing folder", folder_path)
            shutil.rmtree(folder_path)
        # Copy the template folder to the destination
        if self.verbose:
            print("copying content", (TEMPLATE_FOLDER, folder_path))
        shutil.copytree(TEMPLATE_FOLDER, folder_path)
        # Replace the js source with the latest from the repository
        js_path = os.path.join(folder_path, "js")
        if self.verbose:
            print("Copying libraries", (JS_SOURCE_FOLDER, js_path))
        shutil.rmtree(js_path)
        # xxx this copies some unneeded libraries...
        shutil.copytree(JS_SOURCE_FOLDER, js_path)
        # Generate the data files.
        data_folder = os.path.join(folder_path, "data")
        bytes_path = os.path.join(data_folder, "bytes.bin")
        meta_path = os.path.join(data_folder, "meta.json")
        if self.verbose:
            print("Creating data files", (bytes_path, meta_path))
        self.dump_binary(bytes_path)
        self.dump_json_metadata(meta_path, bytes_path)
        # Replace the HTML file using info strings
        html_path = os.path.join(folder_path, "volume.html")
        if self.verbose:
            print("Adjusting HTML content", repr(html_path))
        content = open(html_path).read()
        content = content.replace("VOLUME", self.title)
        content = content.replace("INTRODUCTION", self.explanation)
        f = open(html_path, "w")
        f.write(content)
        f.close()
        if self.verbose:
            print("Done.  View using a web browser:", repr(folder_path))

    def dump_json_metadata(self, to_path, binary_path=None):
        options = self.options.copy()
        options["_description"] = "Volume array meta data."
        options["binary_file"] = binary_path
        outf = open(to_path, "w")
        json.dump(options, outf, indent=4)
        outf.close()
        if self.verbose:
            print ("wrote metadata to", repr(to_path))

    def dump_binary(self, to_path):
        "Dump array in 32 bit float format as bytes with no shape info added."
        values = self.ary.ravel().astype(np.float32)
        binf = open(to_path, "wb")
        values.tofile(binf)
        binf.close()
        if self.verbose:
            print ("wrote", len(values), "floats to", repr(to_path))

    def positional_xyz(self, dictionary):
        # XXX cut/paste from volume.py
        return [dictionary["x"], dictionary["y"], dictionary["z"], ]

TEMPLATE_FOLDER = local_files.vendor_path("html_template")
JS_SOURCE_FOLDER = local_files.vendor_path("js")

class FolderExists(FileExistsError):
    "Folder path exists."